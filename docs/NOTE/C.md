# C语言


## 数据类型和复合数据
### 变量
**变量**: 变量(Variable)是指一个抽象的存储地址，它含有了被称为一个值的某种已知或未知的信息量，并且配对了关联的符号名称。


对于我们物理世界中有很多数据,这些数据在计算机中被储存和表示,由编程语言提供解释方式,称为**数据类型**，这些数据类型可称为原始类型(**Primitive type**),按类型分有

|  数据类型  |  占用空间  |  数值范围  |
|  ----  |  ----  |  ----  |
|  short(短整型)  |  2字节  |  $-2^{15}$ ~ $2^{15}-1$  |
|  int(整型)  |  4字节  |  $-2^{31}$ ~ $2^{31}-1$  |
|  long(长整型)  |  4字节  |  $-2^{31}$ ~ $2^{31}-1$  |
|  long long(长长整型)  |  8字节  |  $-2^{63}$ ~ $2^{63}-1$|
|  float(单浮点)  |  4字节  |  7位有效数字  |
|  double(双浮点)  |  8字节  |  15-16位有效数字  |
|  bool(布尔类型)  |  1字节  |  true/false(0/1)  |
|  char(字符类型)  |  1字节  |  -128-127  |

> 对于变量，就是用于储存数据，在C语言中规定变量必须指定其数据类型(强数据语言)

??? warning "Here" 
    对于字节--计算机中储存数据是二进制形式储存,每一位为一个bit,而对每八个bit划分为一个字节

**变量的声明和定义的辨析**

- 声明是告诉编译器某个变量的存在，以及它的类型。声明并不分配存储空间。例如，外部变量的声明`extern int a`;这里只是告诉编译器有一个类型为`int`的变量a存在，具体的a在哪里定义的，编译器此时并不知道。

> 也就是说，访问未定义的数据时，其值是指向内存中某一个地址的值，具有**不确定性**

- 定义是声明的延伸，除了声明变量的存在和类型以外，还分配了存储空间。例如，int a;就是一个定义，编译器在这里为a分配了足够的存储空间来存储一个整数。

- 在C++中，一个变量可以被声明多次，但只能被定义一次。例如，我们可以在多个文件中声明同一个变量，但只能在一个文件中定义它。如果在多个地方定义同一个变量，编译器会报错

??? tip "针对变量的三个维度"
    - 作用域  
    即变量的生效范围，分为**块作用域**、**函数作用域**、**函数原型作用域**、**文件作用域**  
        1) 块作用域：循环或者条件语句内声明的变量，在这些块中(if for while等等)  
        2) 函数作用域： 函数中声明的变量，包括形参  
        3) 函数原型作用域：函数原型时声明的变量(一般没什么屌用，定义时会创建变量名)  
        4) 文件作用域：在上者的外部，即**全局变量**，可以在整个文件内使用  
    - 链接  
    链接是和编译原理相关的术语，主要影响函数和对象的作用域以及存储方式--是单文件各自使用还是全部文件共享一个变量  
    1) 内部链接：只能被本文件所使用，对于多个`introduced unit`，会产生多个副本  
    2) 外部链接：可以被其他文件访问，整个程序内都有效，并且全局只允许使用一个  
    - 存储期  
    变量创建后的生命周期，分为 **静态存储期**、**自动存储期**、**自定义存储期**  
    以下为不同存储期对应的存储区段：  
    ![segment](../assets/quote/store%20segment.jpg)  
    静态存储期:  
    &nbsp;&nbsp;&nbsp;&nbsp;在数据段中分配的变量，统统拥有静态存储期，因此也都被称为静态变量。这里静态的含义，指的是这些变量的不会因为程序的运行而发生临时性的分配和释放，它们的生命周期是恒定的，跟整个程序一致。  
    包含:  
        ✦ 全局变量:放在函数外的任何变量都为全局变量  
        ✦ static型局部变量(将栈内存存储转为静态存储)  
        ✦ 全局常量/字符串常量  
    注意:若未初始化的全局变量，依照编译器的不同，会自动赋予默认值(一般为0)  
    自动存储期:  
    &nbsp;&nbsp;&nbsp;&nbsp;在栈内存中分配的变量，统统拥有自动存储期，因此也都被称为自动变量。这里自动的含义，指的是这些变量的内存管理不需要开发者操心，都是全自动的：在变量定义处自动分配，出了变量的作用域后自动释放  
    包含:  
        ✦ 局部变量/局部常量  
        ✦ 临时变量  
    自定义存储期:  
    &nbsp;&nbsp;&nbsp;&nbsp;在堆中分配的变量，统统拥有自定义存储期，也就是说这些变量的分配和释放，都是由开发者自己决定的。由于堆内存拥有高度自治权，因此堆是程序开发中用得最多的一片区域。  
    包含:  
        ✦ 动态内存分配  

**算术运算符**  
对于数据类型，都具有算术运算的功能，下表为C支持的所有运算符  
``` C
算术运算符                                                                        逻辑运算符
+	把两个操作数相加                                            &&	与运算符 如果两个操作数都 true，则条件为 true
-	从第一个操作数中减去第二个操作数                               ||  或运算符 如果两个操作数中有任意一个 true，则条件为 true
*	把两个操作数相乘                                             !	非运算符 用来逆转操作数的逻辑状态
/	分子除以分母
%	取模运算符，整除后的余数
++	自增运算符，整数值增加 1
--	自减运算符，整数值减少 1

ps：^ 在c++中不是次幂，而是异或运算符
    自增/减运算符根据在变量的位置不同，效果不同：在前，先进行自的操作再执行语句；在后，先执行语句再自的操作
    &&运算时，从左到右，若左边为0，则直接判顶，不执行后面的语句了！

位运算符
&	按位与操作，按二进制位进行"与"运算                             |  按位或运算符，按二进制位进行"或"运算
0&0=0;                                                             0|0=0;
0&1=0;                                                             0|1=1;
1&0=0;                                                             1|0=1; 
1&1=1;                                                             1|1=1;
^	异或运算符，按二进制位进行"异或"运算                           ~  取反运算符，按二进制位进行"取反"运算
0^0=0;                                                             ~1=-2;
0^1=1;                                                             ~0=-1;
1^0=1;  
1^1=0;
<<	二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）
>>	二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃(注意补1对负数的影响,转原码看！)
注： object <operator> digital --左边是被位移的，右边是位移位数(位置不能换！！！)
     位移的优先级是小于+-这些的，注意加括号
     负数除2不能使用>>来，会出错！！！(算术右移)

ps:位运算符的优先级:>>/<< > & > ^ > | (不是从左到右，那是针对同优先级情况的)

杂项运算符
Condition ? X : Y	条件运算符 如果 Condition 为真 ? 则值为 X : 否则值为 Y
&	指针运算符 & 取变量的地址 例如 &a; 将给出变量的实际地址
*	指针运算符 * 指向一个变量 例如，*var; 将指向变量 var

Extra:
运算符优先级：
1.单目运算符>双目运算符>三目运算符
2.双目中，算术运算符>位运算符>逻辑运算符
3.单目运算符和三目运算符运算是从右向左(其他是从左到右)
4.判断运算符的优先级大于位和算术运算符

```
### 复合数据  
在计算机科学中，复合类型也是一种数据类型，它可以**原始类型**和其它的**复合类型**所构成。构成一个复合类型的动作，又称作组合。  

在C中，按照类别分类，有**数组**、**结构体**、**字符串**、**枚举**、**联合体**。我们在这只讨论C代码实现不讲解严格定义 
#### 数组 
✦ 定义: 具有相同类型的集合  
``` C
typeName arrayName[];//声明数组
typeName arrayName[]={};//同时初始化，[]留空时大小由初始化的数量决定
typeName arrayName []{};C++11的新规范

//数组的访问--x是接受的变量,index是数组的下标(注意是从0开始)
x = arrayName[index];
```  

✦ 数组空间大小  
``` C
数组占用内存空间大小：sizeof(arr)
数组单个元素占用内存空间大小：sizeof(arr[0])
数组长度：sizeof(arr) / sizeof(arr[0])
```  

✦ 获取数组的地址  
``` C
获取数组首地址：arr 或 &arr[0]
注：
&arr：整个数组的地址[地址值相同，含义不同]
通过数组首地址偏移下面的元素只要 +1

```  

  
此外，数组还可以进行嵌套定义，也就是高维数组，看如下代码  

``` C
int arr[2][2] = {{1,2},{3,4}};
int x = arr[0][0];//访问1

///需要注意的是，对于高维数组的定义，只有最右边的可以留空，否则编译器无法自动寻址
int arr[3][] = {...};//合法
int arr[][3] = {...};//不合法，无法确定具体大小
```  
  
> 二维数组的`arr[x][y]`可以理解为x行y列--即顺时针旋转90°的xoy坐标系  

对于数组的未初始化问题，分为下面的三种情况:  
➤ 全局数组，未初始化时，默认值都是0  
➤ 局部数组，未初始化时，默认值未知  
➤ 局部数组，初始化一部分时，未初始化的部分默认值为0  

#### 字符串  
**字符串**(string)，是由零个或多个字符组成的有限序列。一般记为${\displaystyle s=a_{1}a_{2}\dots a_{n}}(0≤n⪇∞){\displaystyle 0\leq n\lneq \infty })$。它是编程语言中表示文本的数据类型。  

C语言中，主要有如下两种定义:  
  
➤ char形式:  
  

``` C
char Name[]={};//二者间必须有参数，否则报错(前面若没有，大小自动为后面的字符数)
//用数组形式储存每一个字符，'',且最后一个必须是空字符\0来结尾，无\0就不是字符串，只是普通的char数组
char Name[]="";//二形式(默认带\0，上面不会带)
char strName;//可以直接声明而不初始化

```  
  
➤ char* 形式:  
``` C
char *str_Name="";//C中形式
const char *str_Name="";//C++的形式

```
  
??? question "为什么指针可以储存字符串呢?"  
    字符串本质其实是一个地址,char数组下第一个字符的首地址,这时程序默认了str_Name存储的就是其**第一字符**的地址  
    ``` C
    例:
    如果 "China"存储在内存中的 0x3000 0x3001 0x3002 0x3003 0x3004 0x3005
    则str_Name="China"=0x3000
    你把China 看作是字符串，但是编译器把它看作是地址 0x3000，即字符串常量的本质表现是代表它的第一个字符的地址
    ```  

??? question "这样创建和`char[]`有什么区别?"  
    - char[]创建相同的字符时会开辟不同的内存空间，而char*则会指向相同字符首字符的地址，但不开辟新的内存空间
    - 数组名(本质常量指针)可以复制给指针表示地址， 但是却不能赋给给数组名
    - 定义时，char[]是分配许多连续的内存单元，单元存储其中的字符，而char*只是保存字符串首地址的指针变量
 
> *extra*: `char* []`是存储`char*`的数组  

下面的是C++特有的数据类型，也可用于存储字符串  
➤ string形式:  
``` C++
string name = "";
string name = {};
string str(name);//生成name的复制品str
访问其中的字符->name[]//数组
name &name[0]获取首地址

///下面是C++的针对字符串类型的函数(在C++中，数据类型被抽象为类--详见面向对象章节)
string a;
a.size();//字符串长度
a.compare();//将字符比较(按字符集对应数字) 字符串的比较依照字典序来进行
a.push_back();//尾插一个字符
a.insert(position,character);//指定位置前插入一个字符
a.append();//拼接一个字符串     也可以用+=来实现
```  
  
    


  
#### 结构体  
**结构体**（struct）是一些元素的集合，这些元素称为结构体的成员（member），且这些成员可以为不同的类型，成员一般用名字访问。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。
  
结构体的定义如下所示，`struct`为结构体关键字，`tag`为结构体的标志，`member-list`为结构体成员列表，其必须列出其所有成员；`variable-list`为此结构体声明的变量。  
``` C
//定义
struct tag { member-list } variable-list ;
```  
一般地对于上式中，`tag`、`memeber-list`、`variable-list`这3部分至少要出现2个；无`tag`时，称为隐式定义<br></br>  
对结构体定义后，可将其视为一种新的复合类型，创建变量来使用结构体  
``` C
//使用
struct tag varible;
struct tag varible = {member-list};
struct tag {mamber-list} varible;//定义结构体时顺便创建变量(放在尾部)
typedef struct tag;(创建变量同上，但是放尾部不是变量，仍然为结构体名)

```
对结构体成员的访问使用`.`运算符
``` C
//访问成员
varible.member;
```  
既然作为复合类型，结构体当然支持嵌套，就如下面的**结构体数组**、**结构体指针**、**结构体嵌套结构体**  
```C
//结构体数组
struct tag array[number] = {{},{},...,{}}
//访问按照嵌套形式就行
array[index].member

//结构体指针
struct tag* varible = &struct_varible;
struct tag* varible = (struct tag*)malloc(sizeof(struct tag));

///结构体嵌套结构体
struct tag1 {struct tag2 varible,member-list}varible-list;
```  
结构体变量作为参数在函数传递的行为同数据类型一样，在这里就不做过多赘述了

<br></br>  

**位段/位域**: 用于结构体中声明成员变量的最大宽度(字节为单位),用于结构体的内存对齐  
``` C
//Attention
位段的成员必须是 int unsigned int或 signed int char（整型家族） ，在C99中位段的成员也可以是其他类型
位段的成员名后跟一个冒号和数字
例：
struct exg{
    int one : 2;//此时限制了one最大字节为2字节
}
```  
> 在C++中，对于结构体，其中还可以定义成员函数(详见面向对象章节)  

<br></br> 

#### 枚举  
**枚举**是一个被命名的**整型常数**的集合，枚举在日常生活中很常见，例如“星期”可以做为一个集合，而其枚举如星期一、星期二、 星期三、星期四、星期五、星期六、星期日，以上称作星期的枚举。下面是定义  
``` C
enum tag {enum-list};
```  
一般来说，枚举的整型常数如果不指定时，都是从0开始计数，可以用户指定数字  
``` C
enum tag {string1 = 1,string2 = 2,string3 = 9,...};
```  
这里需要注意的是，如果第`i`个指定数字时，第`i+1`未指定时，其值是等于上一个数值`+1`的  
``` C
enum tag {string1,string2 = 4,string3}//这时string3的值就是5
```  
> 这意味着枚举成员值允许相等  

<br></br>  

## 条件分支与循环
在程序设计中，需要用到对语句执行流程的控制，同时在对相同执行流程时，要能其简化形式，由此引入 **条件分支**、**循环**。  
  
### 循环  
#### for循环
`for`循环由三部分构成`init-statement condition`,`expression`,`increment`构成，分别是初始化条件，判别表达式，增值表达式    
``` C
for(for-init-statement condition; expression; increment)
{
   statement(s);
}
```  
> 对于increment的前缀表达式在这里还是后缀表达式没有任何区别  

??? tip "Expanding"  
    增强`for`循环: 在传统遍历一个数组时，需要获取数组的长度后通过index一个访问。在增强for循环中，引入如下格式，可以直接访问数组中的每一个成员  
    ``` C
    //一般的，增强for循环则是更为简便的遍历方法，其一般格式如下：(在C11中可以使用auto更方便)
    for(type in_val : array){} //此时的in_val就是在循环内部的变量了
    for(type& in_val : array){}//一般更会使用引用类型，节省空间，因为上面的会复制数组
    ```  

#### while循环  
`while`只有`condition`语句来判断循环  
``` C
while(condition)
{
   statement(s);
}
```  
若单重复语句，可以有如下形式，重复执行`statement`并判断，但是要注意`statement`的更新，防止死循环  
``` C
while(statement);
```  
#### do while循环  
`do while`循环在`while`的基础上，优先执行一遍块内语句，然后行为同`while`循环一致；注意`while`判断后有`;`  
``` C
do
{
   statement(s);
}
while(condition);
```  
### 条件分支 
#### if  
最常见也最经典的就是`if`语句了，格式如下  
``` C
if(condition)
{
   statement(s);
}
//对于单语句
if(condition)
   statement(s);
```  
`if`语句更多的和`else` 和 `else if`语句单独结合，但大多按照`if else if ... else`的来进行多分支组织  
``` C
if(condition)
{
   statement(s);
}
else if(condition)
{
   statement(s);
}
.........//其他多种else if的判断
else
{
   statement(s);
}
``` 
??? warning "else的误区"
    `else`语句具有最近原则，即当你不写`{}`语句块时，else会跟最近的`if`语句，会忽略所谓的层次结构，这一点得注意，见下面例子  
    ``` C
    if(condition) if(condition) statement;
    else statement;//else和内部if匹配


    if(condition) {if(condition) statement;}
    else statement;//else和外部if匹配
    ```  

#### switch  
`switch`等效于`if else if ... else`结构，但是其更加简洁，当分支过多时考虑使用`switch`  
``` C
switch (integer-expression){
     case label1:statement(s);
     case label2:statement(s);
     ..........
     default :statement(2);
}
```  
需要注意的是`integer-expression`和`label`都是而不能是某些变量；对于每个`case`执行完后都会继续执行往下的语句，所以必须加`break`来跳出`switch`；`default`情况等价于`else`  
如下代码段中没加`break`语句的块，执行后会执行下一个`case`语句，直到遇到`break`为止
``` C
switch(expression){
    case label:
        statement;
        break;
    case label2:
        statement;
    case label3:
        statement;
    case label4:
        statement;
        break;
    default:
        statement;//最后一句加不加都无所谓，建议规范加上break
}
```  
该特性可以利用其来对多个条件指向同一行为  
``` C
switch(integer){
    case labe1:case label2:case label3:
        statement;
        break;
    ....

    default:
        statement;
        break;
}
```
<br></br>  
??? note "条件分支和循环控制语句`break`、`continue`、`goto`"  
    - `break`:  
        `break`语句主要结合循环语句，用于跳出**最近**的循环语句中；也用于`switch`语句中的`case`块
    - `continue`:
        `continue`语句用于循环语句中，该语句直接开启下一次循环，其后的语句全部跳过  
    - `goto`:
        `goto`语句为无条件跳转，跳转到任意指定为止（类比`x86`中的`jmp`指令），可以用其**一步跳出多重`for`循环**，使用语法如下  
        ``` C
        格式:
        label: statement(s);
        ........
        goto label;//就是在要跳转的语句前加标签，goto label 执行自动跳转label处
        ```  

## 函数与指针
**引例**:  
看下面两段代码--`seg1`计算$a*b+c$的一段代码，其中`a,b,c`取不同的值；`seg2`计算$n$的阶乘
``` C
///seg1
int main(){
    int a,b,c;
    scanf("%d%d%d",&a,&b,&c);
    printf("%d",a*b+c);
    scanf("%d%d%d",&a,&b,&c);
    printf("%d",a*b+c);
    scanf("%d%d%d",&a,&b,&c);
    printf("%d",a*b+c);
    return 0;    

///seg2
int main(){
    int n;
    scanf("%d",&a);

    int res = 1;
    for(int i = 1;i<=n;i++) res *= i;
    printf("%d",i);
    return 0;
}
}
```  
$~~~~$`seg1`发现存在重复计算的过程，即数据的输入、计算、输出三步骤;`seg2`，可以发现要是我每次求不同的$n!$时，就要书写一次代码段   
$~~~~$对于`seg1`，我们虽然可以使用`for`循环解决，但是我们思考如何用一个语句就可以代替整个过程，以简化对该过程的`coding`；同样对`seg2`我们则想要不书写代码段，而是通过语句的形式来达到相同的效果，提高`coding`效率  


### 函数  
**函数**（function）是指一段可复用的代码块，用于执行特定任务，它通常有输入参数和返回值，能够封装复杂操作并提供**独立的功能入口和出口**。  

函数通过接收数据作为输入，执行预定的计算或操作，然后返回一个结果，从而实现代码的模块化、重用和隐藏细节的目的。  

其中，我们把函数所表示的入口和出口称之为**函数原型**，函数的内部实现方法执行的特定任务称之为**函数定义**，下面是C语言的实现  

``` C
///函数原型
typeName functionName(parameter-list);//有返回类型的函数原型
void functionName(parameter-list);//无返回类型的函数原型

///函数定义
typeName functionName(parameter-list){
    statements;

    return value;//value的类型要和typeName相同
}

void functionName(parameter-list){
    statements;

    return;//可以这样返回，或者不加任何的return语句
}
```  
事实上，函数原型定义（该过程可以称为函数声明）的是函数名、返回值类型、接受值类型，因此实际不需要写形参（例：`int addThree(int a)`和`int addThree(int)`是等价的）  

??? question "明明函数定义就够了，为何还要使用函数原型呢？"
    函数原型只说明了该函数的输入和输出，也就是起到**接口**的作用，当只有函数原型的时候，我们可以随时更改函数的实现细节，来看下面的一段话  
    > $~~~~$函数原型被广泛应用于C、C++ 语言程序代码的上下文中，通过在头文件中放置函数的前向声明来允许将代码拆分为多个翻译单元。即编译器可以**单独**编译目标文件的这部分内容，然后由链接器组合成可执行文件或库。  
    
    假设有文件`a.c`，`b.c`，`d.c`三个文件，`a.c`含义某个函数原型，`b.c`和`d.c`含有该函数不同定义，则当`a.c`单独和`b.c`或`d.c`编译链接时，函数的效果就可以不一样，也就是说我们可以混合编译  
    
    还有一种情况就是代码规范，当在`main()`函数前写过多的函数定义时会显得冗杂，而我们先函数原型后再在`main()`函数后写函数定义，这样在查看代码时，对不同函数的接口一目了然又不会影响函数的正常执行


当创建完函数后，我们通过以下方式来使用函数  
``` C
functionName(arg-list);//arg-list为传入的参数，变量类型要一致，不一致会强制类型转换
```  
对于有返回值的函数，可以使用`varible`来接受它，也可以不做任何处理  
``` C
varible = functionName(arg-list);
functionName(arg-list);
```  
**形参**和**实参**：形参即为函数声明或函数定义时规定的参数；实参即为实际调用函数时传入的参数（可以类比数学中的$f(x,y)$和$f(2,3)$），看下面的例子  
``` C
void print(int a,int b);

print(123,456);
```  
  
**函数传参**: 在调用函数的过程中，外部变量传入到函数的过程  
